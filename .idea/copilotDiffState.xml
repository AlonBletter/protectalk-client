<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/MainActivity.kt" />
              <option name="originalContent" value="package com.protectalk.protectalk&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.core.content.ContextCompat&#10;import androidx.navigation.compose.rememberNavController&#10;import com.protectalk.protectalk.navigation.AppNavHost&#10;import com.protectalk.protectalk.push.PushManager&#10;import com.protectalk.protectalk.alert.AlertManager&#10;import com.protectalk.protectalk.ui.theme.ProtectTalkTheme&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;Notification permission granted&quot;)&#10;        } else {&#10;            Log.w(&quot;MainActivity&quot;, &quot;Notification permission denied&quot;)&#10;        }&#10;    }&#10;&#10;    private val requestAlertPermissionsLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val grantedPermissions = permissions.filterValues { it }.keys&#10;        val deniedPermissions = permissions.filterValues { !it }.keys&#10;&#10;        Log.d(&quot;MainActivity&quot;, &quot;Alert permissions granted: $grantedPermissions&quot;)&#10;        Log.d(&quot;MainActivity&quot;, &quot;Alert permissions denied: $deniedPermissions&quot;)&#10;&#10;        // Check if we have the essential permissions needed for the current Android version&#10;        val hasEssentialPermissions = AlertManager.hasRequiredPermissions(this)&#10;        val missingCritical = AlertManager.getMissingPermissions(this)&#10;&#10;        if (hasEssentialPermissions) {&#10;            Log.i(&quot;MainActivity&quot;, &quot;All required alert permissions granted for API ${android.os.Build.VERSION.SDK_INT}, starting monitoring&quot;)&#10;            AlertManager.startAlertMonitoring(this)&#10;        } else {&#10;            Log.w(&quot;MainActivity&quot;, &quot;Missing critical permissions: $missingCritical - alert monitoring cannot start&quot;)&#10;            // You might want to show a dialog explaining why these permissions are needed&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize FCM token early in app lifecycle&#10;        initializeFcmToken()&#10;&#10;        // Request notification permission for Android 13+&#10;        requestNotificationPermission()&#10;&#10;        // Request alert monitoring permissions&#10;        requestAlertPermissions()&#10;&#10;        setContent {&#10;            ProtectTalkTheme { // Custom light green theme&#10;                Surface {&#10;                    val navController = rememberNavController()&#10;                    AppNavHost(navController)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeFcmToken() {&#10;        // Fetch FCM token asynchronously on app start&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                PushManager.fetchFcmToken()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;Failed to initialize FCM token&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    this,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    Log.d(&quot;MainActivity&quot;, &quot;Notification permission already granted&quot;)&#10;                }&#10;                else -&gt; {&#10;                    Log.d(&quot;MainActivity&quot;, &quot;Requesting notification permission&quot;)&#10;                    requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestAlertPermissions() {&#10;        val missingPermissions = AlertManager.getMissingPermissions(this)&#10;&#10;        if (missingPermissions.isEmpty()) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;All alert permissions already granted&quot;)&#10;            // Start monitoring if permissions are already granted&#10;            AlertManager.startAlertMonitoring(this)&#10;        } else {&#10;            Log.d(&quot;MainActivity&quot;, &quot;Requesting alert permissions: $missingPermissions&quot;)&#10;            requestAlertPermissionsLauncher.launch(AlertManager.getRequiredPermissions())&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        // Note: We don't stop alert monitoring here because we want it to continue&#10;        // even when the app is closed. The monitoring will stop when user logs out.&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.protectalk.protectalk&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.navigation.compose.rememberNavController&#10;import com.protectalk.protectalk.navigation.AppNavHost&#10;import com.protectalk.protectalk.permissions.PermissionManager&#10;import com.protectalk.protectalk.push.PushManager&#10;import com.protectalk.protectalk.alert.AlertManager&#10;import com.protectalk.protectalk.ui.theme.ProtectTalkTheme&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var permissionManager: PermissionManager&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize permission manager for comprehensive permission handling&#10;        permissionManager = PermissionManager(this)&#10;&#10;        // Initialize FCM token early in app lifecycle&#10;        initializeFcmToken()&#10;&#10;        // Request all necessary permissions for scam detection functionality&#10;        requestAllPermissions()&#10;&#10;        setContent {&#10;            ProtectTalkTheme { // Custom light green theme&#10;                Surface {&#10;                    val navController = rememberNavController()&#10;                    AppNavHost(navController)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeFcmToken() {&#10;        // Fetch FCM token asynchronously on app start&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                PushManager.fetchFcmToken()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MainActivity&quot;, &quot;Failed to initialize FCM token&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Request all permissions required for scam detection functionality&#10;     * This includes essential, audio processing, and enhanced permissions&#10;     */&#10;    private fun requestAllPermissions() {&#10;        Log.d(&quot;MainActivity&quot;, &quot;Starting comprehensive permission request for scam detection&quot;)&#10;&#10;        // Log current permission status for debugging&#10;        val currentStatus = permissionManager.getPermissionStatus()&#10;        Log.d(&quot;MainActivity&quot;, &quot;Current permission status: $currentStatus&quot;)&#10;&#10;        permissionManager.requestAllPermissions { allCriticalGranted -&gt;&#10;            if (allCriticalGranted) {&#10;                Log.i(&quot;MainActivity&quot;, &quot;✅ All critical permissions granted - scam detection fully enabled&quot;)&#10;&#10;                // Start alert monitoring with full functionality&#10;                AlertManager.startAlertMonitoring(this)&#10;&#10;                // Log final permission status&#10;                val finalStatus = permissionManager.getPermissionStatus()&#10;                Log.d(&quot;MainActivity&quot;, &quot;Final permission status: $finalStatus&quot;)&#10;&#10;            } else {&#10;                Log.w(&quot;MainActivity&quot;, &quot;⚠️ Some critical permissions denied - limited functionality&quot;)&#10;&#10;                // Still try to start monitoring with available permissions&#10;                if (permissionManager.checkEssentialPermissions()) {&#10;                    Log.i(&quot;MainActivity&quot;, &quot;Starting limited alert monitoring with essential permissions only&quot;)&#10;                    AlertManager.startAlertMonitoring(this)&#10;                } else {&#10;                    Log.e(&quot;MainActivity&quot;, &quot;❌ Essential permissions missing - cannot start alert monitoring&quot;)&#10;                }&#10;&#10;                // Show which permissions are missing&#10;                val finalStatus = permissionManager.getPermissionStatus()&#10;                Log.w(&quot;MainActivity&quot;, &quot;Missing permissions status: $finalStatus&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;&#10;        // Check if permissions have changed (user might have granted them in settings)&#10;        if (permissionManager.checkEssentialPermissions()) {&#10;            Log.d(&quot;MainActivity&quot;, &quot;Essential permissions available - ensuring monitoring is active&quot;)&#10;            AlertManager.startAlertMonitoring(this)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        // Note: We don't stop alert monitoring here because we want it to continue&#10;        // even when the app is closed. The monitoring will stop when user logs out.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/alert/BootReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/alert/BootReceiver.kt" />
              <option name="updatedContent" value="package com.protectalk.protectalk.alert&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;&#10;/**&#10; * Receiver to restart alert monitoring after device boot.&#10; * This ensures scam detection continues working after device restarts.&#10; */&#10;class BootReceiver : BroadcastReceiver() {&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;BootReceiver&quot;&#10;    }&#10;    &#10;    override fun onReceive(context: Context, intent: Intent) {&#10;        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {&#10;            Log.i(TAG, &quot; Device boot completed - checking if alert monitoring should restart&quot;)&#10;            &#10;            try {&#10;                // Only restart monitoring if we have the required permissions&#10;                // and the user was previously using the app&#10;                if (AlertManager.hasRequiredPermissions(context)) {&#10;                    Log.i(TAG, &quot;✅ Permissions available - restarting alert monitoring after boot&quot;)&#10;                    AlertManager.startAlertMonitoring(context)&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ Required permissions not available - cannot restart monitoring&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error restarting alert monitoring after boot&quot;, e)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/permissions/PermissionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/protectalk/protectalk/permissions/PermissionManager.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.protectalk.protectalk.permissions&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;&#10;/**&#10; * Manages all runtime permissions required for scam detection functionality.&#10; * Handles both install-time and runtime permission requests with proper fallbacks.&#10; */&#10;class PermissionManager(private val activity: ComponentActivity) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;PermissionManager&quot;&#10;&#10;        // Essential permissions for basic functionality&#10;        private val ESSENTIAL_PERMISSIONS = listOfNotNull(&#10;            Manifest.permission.READ_PHONE_STATE,&#10;            Manifest.permission.READ_CALL_LOG,&#10;            // Only request POST_NOTIFICATIONS on Android 13+&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                Manifest.permission.POST_NOTIFICATIONS&#10;            } else null&#10;        )&#10;&#10;        // Audio processing permissions for scam detection&#10;        private val AUDIO_PERMISSIONS = listOfNotNull(&#10;            Manifest.permission.RECORD_AUDIO,&#10;            Manifest.permission.READ_EXTERNAL_STORAGE,&#10;            // Only request READ_MEDIA_AUDIO on Android 13+&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                Manifest.permission.READ_MEDIA_AUDIO&#10;            } else null&#10;        )&#10;&#10;        // Optional enhanced permissions&#10;        private val ENHANCED_PERMISSIONS = listOfNotNull(&#10;            Manifest.permission.READ_CONTACTS,&#10;            // Only request ANSWER_PHONE_CALLS on Android 8.0+&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                Manifest.permission.ANSWER_PHONE_CALLS&#10;            } else null,&#10;            Manifest.permission.CALL_PHONE&#10;        )&#10;    }&#10;&#10;    private var onPermissionResult: ((Boolean) -&gt; Unit)? = null&#10;&#10;    // Permission launchers&#10;    private val essentialPermissionLauncher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt; =&#10;        activity.registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -&gt;&#10;            val allEssentialGranted = ESSENTIAL_PERMISSIONS.all { permissions[it] == true }&#10;            Log.d(TAG, &quot;Essential permissions result: $allEssentialGranted&quot;)&#10;&#10;            if (allEssentialGranted) {&#10;                requestAudioPermissions()&#10;            } else {&#10;                Log.w(TAG, &quot;Essential permissions are required for the app to function&quot;)&#10;                onPermissionResult?.invoke(false)&#10;            }&#10;        }&#10;&#10;    private val audioPermissionLauncher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt; =&#10;        activity.registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -&gt;&#10;            val audioGranted = AUDIO_PERMISSIONS.any { permissions[it] == true }&#10;            Log.d(TAG, &quot;Audio permissions result: $audioGranted&quot;)&#10;&#10;            requestEnhancedPermissions()&#10;        }&#10;&#10;    private val enhancedPermissionLauncher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt; =&#10;        activity.registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -&gt;&#10;            val enhancedGranted = ENHANCED_PERMISSIONS.count { permissions[it] == true }&#10;            Log.d(TAG, &quot;Enhanced permissions granted: $enhancedGranted/${ENHANCED_PERMISSIONS.size}&quot;)&#10;&#10;            requestSystemAlertPermission()&#10;        }&#10;&#10;    private val systemAlertPermissionLauncher: ActivityResultLauncher&lt;Intent&gt; =&#10;        activity.registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {&#10;            val hasSystemAlertPermission = Settings.canDrawOverlays(activity)&#10;            Log.d(TAG, &quot;System alert permission: $hasSystemAlertPermission&quot;)&#10;&#10;            val allCriticalGranted = checkEssentialPermissions() &amp;&amp; checkAudioPermissions()&#10;            onPermissionResult?.invoke(allCriticalGranted)&#10;        }&#10;&#10;    /**&#10;     * Requests all necessary permissions in stages for optimal user experience&#10;     */&#10;    fun requestAllPermissions(onResult: (Boolean) -&gt; Unit) {&#10;        onPermissionResult = onResult&#10;&#10;        when {&#10;            checkAllPermissions() -&gt; {&#10;                Log.d(TAG, &quot;All permissions already granted&quot;)&#10;                onResult(true)&#10;            }&#10;            else -&gt; {&#10;                Log.d(TAG, &quot;Starting permission request flow&quot;)&#10;                requestEssentialPermissions()&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stage 1: Request essential permissions (required for basic functionality)&#10;     */&#10;    private fun requestEssentialPermissions() {&#10;        val missingEssential = ESSENTIAL_PERMISSIONS.filter { !isPermissionGranted(it) }&#10;&#10;        if (missingEssential.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Requesting essential permissions: $missingEssential&quot;)&#10;            essentialPermissionLauncher.launch(missingEssential.toTypedArray())&#10;        } else {&#10;            requestAudioPermissions()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stage 2: Request audio processing permissions (critical for scam detection)&#10;     */&#10;    private fun requestAudioPermissions() {&#10;        val missingAudio = AUDIO_PERMISSIONS.filter { !isPermissionGranted(it) }&#10;&#10;        if (missingAudio.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Requesting audio permissions: $missingAudio&quot;)&#10;            audioPermissionLauncher.launch(missingAudio.toTypedArray())&#10;        } else {&#10;            requestEnhancedPermissions()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stage 3: Request enhanced permissions (optional but recommended)&#10;     */&#10;    private fun requestEnhancedPermissions() {&#10;        val missingEnhanced = ENHANCED_PERMISSIONS.filter { !isPermissionGranted(it) }&#10;&#10;        if (missingEnhanced.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Requesting enhanced permissions: $missingEnhanced&quot;)&#10;            enhancedPermissionLauncher.launch(missingEnhanced.toTypedArray())&#10;        } else {&#10;            requestSystemAlertPermission()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stage 4: Request system alert window permission (special permission)&#10;     */&#10;    private fun requestSystemAlertPermission() {&#10;        if (!Settings.canDrawOverlays(activity)) {&#10;            Log.d(TAG, &quot;Requesting system alert window permission&quot;)&#10;            val intent = Intent(&#10;                Settings.ACTION_MANAGE_OVERLAY_PERMISSION,&#10;                Uri.parse(&quot;package:${activity.packageName}&quot;)&#10;            )&#10;            systemAlertPermissionLauncher.launch(intent)&#10;        } else {&#10;            val allCriticalGranted = checkEssentialPermissions() &amp;&amp; checkAudioPermissions()&#10;            onPermissionResult?.invoke(allCriticalGranted)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if a specific permission is granted&#10;     */&#10;    private fun isPermissionGranted(permission: String): Boolean {&#10;        return ContextCompat.checkSelfPermission(activity, permission) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    /**&#10;     * Check if all essential permissions are granted&#10;     */&#10;    fun checkEssentialPermissions(): Boolean {&#10;        return ESSENTIAL_PERMISSIONS.all { isPermissionGranted(it) }&#10;    }&#10;&#10;    /**&#10;     * Check if audio permissions are granted (at least one for compatibility)&#10;     */&#10;    fun checkAudioPermissions(): Boolean {&#10;        return AUDIO_PERMISSIONS.any { isPermissionGranted(it) }&#10;    }&#10;&#10;    /**&#10;     * Check if all permissions are granted&#10;     */&#10;    private fun checkAllPermissions(): Boolean {&#10;        val regularPermissions = ESSENTIAL_PERMISSIONS + AUDIO_PERMISSIONS + ENHANCED_PERMISSIONS&#10;        val systemAlert = Settings.canDrawOverlays(activity)&#10;&#10;        return regularPermissions.all { isPermissionGranted(it) } &amp;&amp; systemAlert&#10;    }&#10;&#10;    /**&#10;     * Get permission status summary for debugging&#10;     */&#10;    fun getPermissionStatus(): Map&lt;String, Boolean&gt; {&#10;        return mapOf(&#10;            &quot;Essential&quot; to checkEssentialPermissions(),&#10;            &quot;Audio&quot; to checkAudioPermissions(),&#10;            &quot;SystemAlert&quot; to Settings.canDrawOverlays(activity),&#10;            &quot;AllGranted&quot; to checkAllPermissions()&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>